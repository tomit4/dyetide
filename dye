#!/usr/bin/env bash
# set -vx
# set x

printhelp() {
    cat <<EOM
usage: dye [-x|-r] [color_code] "input_color"
options:
 -x [color_code]          hex to [color_code]
 -r [color_code]          rgb to [color_code]
 -h [color_code]          hsl to [color_code]
examples:
 dye -x rgb "#fff"
 dye -x rgb "#ffffff"
 dye -x rgb "#43fF6480"
 dye -r hex "rgb(255, 255, 255)"
 dye -r hsl "rgba(67, 255, 100, 0.8)"
 dye -r hex "rgba(67, 255, 100, 0.5)"
 dye -h hex "hsla(350, 100, 100, 1.0)"
 dye -h rgb "hsl(350, 100, 100)"
EOM
    exit 0
}

error() {
    printf "error: %s\n" "$1" 1>&2
    exit 2
}

parse_args() {
    orig_color=$1
    color_to_conv=$2
    passed_color_code=$3
    accepted_colors=( "rgb"  "hex" "hsl" )

    # check if passed color code exists in accepted_colors array
    if [[ ! "${accepted_colors[*]}" =~ ${color_to_conv} ]]; then
        error "$color_to_conv is not an accepted color format"
    fi

    # create an array of color_to_conv values to check first
    if [[ "$orig_color" == "-h" ]]; then
        local regex='^hsl[a]?[(][0-9]{1,3}, [0-9]{1,3}, [0-9]{1,3}[)]$|^hsl[a]?[(][0-9]{1,3}, [0-9]{1,3}, [0-9]{1,3}, [0-1]?.?[0-9]?[0-9][)]$'
        local numbers
        numbers=$(echo "$passed_color_code" | sed -n 's/.*\(([^()]*)\).*/\1/p' | sed 's/[()]//g' | sed 's/,\s/ /g')
        read -r -a hsl <<< "$numbers"
    if [[ $passed_color_code =~ $regex ]]; then
        if [[ $color_to_conv == "rgb" ]]; then
            hsl_to_rgb  "${hsl[$"0"]}" "${hsl[$"1"]}" "${hsl[$"2"]}" "${hsl[$"3"]}"
        elif [[ $color_to_conv == "hex" ]]; then
            hsl_to_hex  "${hsl[$"0"]}" "${hsl[$"1"]}" "${hsl[$"2"]}" "${hsl[$"3"]}"
        fi
    else
        error "$passed_color_code is not a recognized hsla code"
    fi
    elif [[ "$orig_color" == "-r" ]]; then
        local regex='^rgb[a]?[(][0-9]{1,3}, [0-9]{1,3}, [0-9]{1,3}[)]$|^rgb[a]?[(][0-9]{1,3}, [0-9]{1,3}, [0-9]{1,3}, [0-1]?.?[0-9][0-9]?[)]$'
        local numbers
        numbers=$(echo "$passed_color_code" | sed -n 's/.*\(([^()]*)\).*/\1/p' | sed 's/[()]//g' | sed 's/,\s/ /g')
        read -r -a rgb <<< "$numbers"
        rgb_check "${rgb[$"0"]}" "${rgb[$"1"]}" "${rgb[$"2"]}" "${rgb[$"3"]}"
        if [[ $passed_color_code =~ $regex ]]; then
            if [[ $color_to_conv == "hex" ]]; then
                rgb_to_hex  "${rgb[$"0"]}" "${rgb[$"1"]}" "${rgb[$"2"]}" "${rgb[$"3"]}"
            elif [[ $color_to_conv == "hsl" ]]; then
                rgb_to_hsl  "${rgb[$"0"]}" "${rgb[$"1"]}" "${rgb[$"2"]}" "${rgb[$"3"]}"
            fi
        else
            error "$passed_color_code is not a recognized rgba code"
        fi

    fi
}

rgb_check() {
    if [ "$1" -lt 0 ] || [ "$1" -gt 255 ] || \
        [ "$2" -lt 0 ] || [ "$2" -gt 255 ] || \
        [ "$3" -lt 0 ] || [ "$3" -gt 255 ]; then
        error "invalid rgb values passed."
    fi
}

hex_to_rgb() {
    local a
    # null command ':' removes all leading hashtag characters
    : "${3/\#/}"
    # if hex value is 8 characters
    if ((${#_} == 8)); then
        # convert characters to hex
        ((r = 16#${_:0:2}, g = 16#${_:2:2}, b = 16#${_:4:2}, a = 16#${_:6:2}))
        # simple calc for alpha channel
        a=$(echo "scale=2; $a / 255" | bc -l)
    # else if hex value is 6 characters (no alpha channel)
    elif ((${#_} == 6)); then
        ((r = 16#${_:0:2}, g = 16#${_:2:2}, b = 16#${_:4:2}))
    # else if hex value is 3 characters (minimal hex value provided)
    elif ((${#_} == 3)); then
        ((r = 16#${_:0:1}${_:0:1}, g = 16#${_:1:1}${_:1:1}, b = 16#${_:2:1}${_:2:1}))
    else
        error "$3 is not a recognized hex color code."
    fi
    if [[ -n "$a" ]]; then
        printf "%s\n" "rgba($r, $g, $b, $a)"
    else
        printf "%s\n" "rgb($r, $g, $b)"
    fi
}

dec_to_float() {
    echo "scale=2; $1 / 255" | bc -l -l
}

find_min_max() {
    max=$1
    min=$1
    for arg in "$@"
    do
        if (( "$(echo "$arg $max" | awk '{print ($1 > $2)}')" )); then
            max=$(echo "$arg" | awk '{print $1}')
        elif (( "$(echo "$arg $min)" | awk '{print ($1 < $2)}')" )); then
            min=$(echo "$arg" | awk '{print $1}')
        fi
    done
}

calculate_saturation() {
    local min=$1
    local max=$2
    l=$3
    if [[ $(echo "$max == $min" | bc -l) -eq 1 ]]; then
        printf "%.0f" 0
    else
        if [[ $(echo "$l < 0.5" | bc -l) -eq 1 ]]; then
            printf "%.0f" "$(echo "scale=2; (($max - $min) / ($max + $min) * 100)" | bc -l)"
        else
            printf "%.0f" "$(echo "scale=2; (($max - $min) / (2 - $max - $min) * 100)" | bc -l)"
        fi
    fi
}

calculate_hue() {
    local min=$1
    local max=$2
    if [[ $(echo "$max == $min" | bc -l) -eq 1 ]]; then
        printf "%.0f" 0
    else
        if [[ $(echo "$r == $max" | bc -l) -eq 1 ]]; then
            printf "%.0f" "$(echo "scale=2; 60 * (($g - $b) / ($max - $min))" | bc -l)"
        elif [[ $(echo "$g == $max" | bc -l) -eq 1 ]]; then
            printf "%.0f" "$(echo "scale=2; 60 * (($b - $r) / ($max - $min)) + 120" | bc -l)"
        else
            printf "%.0f" "$(echo "scale=2; 60 * (($r -$g) / ($max - $min)) + 240" | bc -l)"
        fi
    fi
}

hex_to_hsl() {
    local a=1.0
    : "${3/\#/}"
    if ((${#_} == 8)); then
        ((r = 16#${_:0:2}, g = 16#${_:2:2}, b = 16#${_:4:2}, a = 16#${_:6:2}))
        a=$(echo "scale=2; $a / 255" | bc -l)
    elif ((${#_} == 6)); then
        ((r = 16#${_:0:2}, g = 16#${_:2:2}, b = 16#${_:4:2}))
    elif ((${#_} == 3)); then
        ((r = 16#${_:0:1}, g = 16#${_:1:1}, b = 16#${_:2:1}))
        r=$((r * 16 + r))
        g=$((g * 16 + g))
        b=$((b * 16 + b))
    fi
    r=$(dec_to_float "$r")
    g=$(dec_to_float "$g")
    b=$(dec_to_float "$b")
    find_min_max "$r" "$g" "$b"
    l=$(printf "%.0f" "$(echo "scale=2; (($max + $min) / 2 * 100)" | bc -l)")
    s=$(calculate_saturation "$min" "$max" "$l")
    h=$(calculate_hue "$min" "$max")
    if [[ $(echo "$h < 0" | bc -l) -eq 1 ]]; then
        h=$(echo "scale=2; $h + 360" | bc -l)
    fi
    printf "%s\n" "hsla($h, $s, $l, $a)"
}

rgb_to_hex() {
    local a
    if [[ -n "$4" ]]; then
        # converts alpha channel to hex (see below)
        a=$(printf "%02x\n" "$(echo "scale=0; $4*255" | bc -l)" 2>/dev/null)
        if [[ $a -gt 1 ]]; then
            error "alpha channel cannot be greater than 1.0"
        fi
        # pads hex value with leading 0s
        printf "#%02x%02x%02x%s\n" "$1" "$2" "$3" "$a"
    else
        # pads hex value with leading 0s
        printf "#%02x%02x%02x\n" "$1" "$2" "$3"
    fi
}

rgb_to_hsl() {
    r=$(echo "scale=2; $1 / 255" | bc -l)
    g=$(echo "scale=2; $2 / 255" | bc -l)
    b=$(echo "scale=2; $3 / 255" | bc -l)

    find_min_max "$r" "$g" "$b"

    h=$(echo "scale=2; ($max + $min) / 2" | bc -l)
    s=$(echo "scale=2; ($max + $min) / 2" | bc -l)
    l=$(echo "scale=2; ($max + $min) / 2" | bc -l)

    if (( $(echo "$min $max" | awk '{print ($1 == $2)}') )); then
        h=0
        s=0
        l="$(echo "scale=0; $max + $min" | bc -l)"
    else
        #calculate difference between max and min
        d="$(echo "scale=2; $max - $min" | bc -l)"

        # calculate hue
        if (( $(echo "$max $r" | awk '{print ($1 == $2)}') )); then
            h=$(echo "scale=2; ($g - $b) / $d" | bc -l)
            if (( $(echo "$g $b" | awk '{print ($1 < $2)}') )); then
                h=$(echo "scale=2; $h + 6" | bc -l)
            fi
        elif (( $(echo "$max $g" | awk '{print ($1 == $2)}') )); then
            h=$(echo "scale=2; ($b - $r) / $d + 2" | bc -l)
        else
            h=$(echo "scale=2; ($r - $g) / $d + 4" | bc -l)
        fi

        h=$(echo "scale=2; $h / 6" | bc -l)

        # calculate saturation
        if (( $(echo "$l 0.5" | awk '{print ($1 > $2)}') )); then
            s=$(echo "scale=2; $d / (2 - $max - $min)" | bc -l)
        else
            s=$(echo "scale=2; $d / ($max + $min)" | bc -l)
        fi

        # calculate lightness
        l=$(echo "scale=2; ($max + $min) / 2" | bc -l)
    fi

    # convert back to 360 color wheel values
    h=$(printf "%.0f" "$(echo "$h * 360" | bc -l)")
    s=$(printf "%.0f" "$(echo "$s * 100" | bc -l)")
    l=$(printf "%.0f" "$(echo "$l * 100" | bc -l)")

    # if a fourth arg is provided (alpha channel)
    if [[ -n "$4" ]]; then
        a="$4"
        if [[ $(echo "scale=2; $a > 1" | bc -l) -eq 1 ]]; then
            error "alpha channel cannot be greater than 1.0"
        fi
    else
        a=""
    fi

    if [[ -n "$a" ]]; then
        printf "%s\n" "hsla($h, $s, $l, $a)"
    else
        printf "%s\n" "hsla($h, $s, $l)"
    fi
}

hue_to_rgb() {
    # p=mid
    # q=chroma
    # t=hue
    p=$1 q=$2 t=$3

    if [[ $(echo "$t < 0" | bc -l) -eq "1" ]]; then
        t=$(echo "scale=6; $t + 1" | bc -l)
    fi
    if [[ $(echo "$t > 1" | bc -l) -eq "1" ]]; then
        t=$(echo "scale=6; $t - 1" | bc -l)
    fi

    if [[ $(echo "$t <= 1 / 6" | bc -l) -eq "1" ]]; then
        p=$(echo "scale=6; $p + ($q - $p) * 6 * $t" | bc -l)
        echo "$p"
        exit 0
    elif [[ $(echo "$t < 1 / 2" | bc -l) -eq "1" ]]; then
        p=$q
        echo "$p"
        exit 0
    elif [[ $(echo "$t < 2 / 3" | bc -l) -eq "1" ]]; then
        p=$(echo "scale=6; $p + ($q - $p) * (2 / 3 - $t) * 6" | bc -l)
        echo "$p"
        exit 0
    fi
    echo "$p"
}

hsl_to_rgb() {
    local h s l r g b
    # keep the hue within 0 - 360
    h="$((($1 % 360 % 360) % 360))"
    # keep the saturation between 0 -100
    s="$((($2 > 100 ? 100 : $2 < 0 ? 0 : $2)))"
    l="$((($3 > 100 ? 100 : $3 < 0 ? 0 : $3)))"

    # convert all values to between 0 - 1
    h=$(echo "scale=6; $1 / 360" | bc -l)
    s=$(echo "scale=6; $2 / 100" | bc -l)
    l=$(echo "scale=6; $3 / 100" | bc -l)

    # if a fourth arg is provided (alpha channel)
    if [[ -n "$4" ]]; then
        a=$4
        if [[ $(echo "scale=2; $a > 1" | bc -l) -eq 1 ]]; then
            error "alpha channel cannot be greater than 1.0"
        fi
    fi

    # color is grey and all three rgb values should be equal to the original
    # lightness value
    if [[ $2 -eq 0 ]]; then
        r=$3
        g=$3
        b=$3
        printf "%s\n" "$r $g $b $a"
        exit 0
    else
        local q p
        if [[ "$l" < .50 ]]; then
            q=$(echo "scale=6; $l * (100 + $s)" | bc -l)
        else
            q=$(echo "scale=6; $l + $s - $l * $s" | bc -l)
        fi
        p=$(echo "scale=6; 2 * $l - $q" | bc -l)
        # r=$(hue_to_rgb "$p" "$q" "$(echo "scale=1; $h + 1 / 3" | bc -l)")
        r=$(hue_to_rgb "$p" "$q" "$(echo "$h" | awk '{print $1 + (1 / 3)}')")
        g=$(hue_to_rgb "$p" "$q" "$h")
        b=$(hue_to_rgb "$p" "$q" "$(echo "$h" | awk '{print $1 - (1 / 3)}')")
    fi

    # convert final returned values from hue_to_rgb into full rgb codes by * 255
    r="$(printf "%.0f" "$(echo "scale=6; $r * 255" | bc -l)")"
    g="$(printf "%.0f" "$(echo "scale=6; $g * 255" | bc -l)")"
    b="$(printf "%.0f" "$(echo "scale=6; $b * 255" | bc -l)")"
    # clamp the results between 0 and 255 values
    r=$(echo "$r" | awk '{print ($1 > 255 ? 255 : $1 < 0 ? 0 : $1)}' | xargs printf "%d")
    g=$(echo "$g" | awk '{print ($1 > 255 ? 255 : $1 < 0 ? 0 : $1)}' | xargs printf "%d")
    b=$(echo "$b" | awk '{print ($1 > 255 ? 255 : $1 < 0 ? 0 : $1)}' | xargs printf "%d")

    if [[ -n "$a" ]]; then
        printf "%s\n" "rgba($r, $g, $b, $a)"
    else
        printf "%s\n" "rgb($r, $g, $b)"
    fi
}

#since i have these already...
hsl_to_hex() {
    rgb_code="$(hsl_to_rgb "$@")"
    parse_args "-r" "hex" "$rgb_code"
}

main() {
    [[ "$#" -lt 1 ]] && printhelp

    while getopts ":x:r:h:?" arg; do
        case $arg in
            x)
                if [[ "$2" == "rgb" ]]; then
                    local rgbval clipit
                    rgbval=$(hex_to_rgb "$@")
                    printf "%s\n" "$rgbval"
                    read -e -r -p "save code to clipboard?(y/n): " clipit
                    if [[ "$clipit" == "yes" || "$clipit" == "y" ]]; then
                        printf "%s" "$rgbval" | xclip -sel clip
                    fi
                elif [[ "$2" == "hsl" ]]; then
                    local hslval clipit
                    hslval=$(hex_to_hsl "$@")
                    printf "%s\n" "$hslval"
                    read -e -r -p "save code to clipboard?(y/n): " clipit
                    if [[ "$clipit" == "yes" || "$clipit" == "y" ]]; then
                        printf "%s" "$hslval" | xclip -sel clip
                    fi
                fi
                ;;
            r)
                if [[ "$2" == "hex" ]]; then
                    local hexval clipit
                    hexval=$(parse_args "$@")
                    printf "%s\n" "$hexval"
                    read -e -r -p "save code to clipboard?(y/n): " clipit
                    if [[ "$clipit" == "yes" || "$clipit" == "y" ]]; then
                        printf "%s" "$hexval" | xclip -sel clip
                    fi
                elif [[ "$2" == "hsl" ]]; then
                    local hslval clipit
                    hslval=$(parse_args "$@")
                    printf "%s\n" "$hslval"
                    read -e -r -p "save code to clipboard?(y/n): " clipit
                    if [[ "$clipit" == "yes" || "$clipit" == "y" ]]; then
                        printf "%s" "$hslval" | xclip -sel clip
                    fi
                fi
                ;;
            h)
                if [[ "$2" == "hex" ]]; then
                    local hexval
                    hexval=$(parse_args "$@")
                    printf "%s\n" "$hexval"
                    read -e -r -p "save code to clipboard?(y/n): " clipit
                    if [[ "$clipit" == "yes" || "$clipit" == "y" ]]; then
                        printf "%s" "$hexval" | xclip -sel clip
                    fi
                elif [[ "$2" == "rgb" ]]; then
                    local rgbval clipit
                    rgbval=$(parse_args "$@")
                    printf "%s\n" "$rgbval"
                    read -e -r -p "save code to clipboard?(y/n): " clipit
                    if [[ "$clipit" == "yes" || "$clipit" == "y" ]]; then
                        printf "%s" "$rgbval" | xclip -sel clip
                    fi
                fi
                ;;
            ?)
                printhelp
                ;;
        esac
    done
}

main "$@"

# Credits:
# Thanks go out to those who helped:

# Akash Mittal, whose article provided the original versions of hex_to_rgb() and rgb_to_hex() taken from
# https://akashmittal.com/code-example-convert-hex-color-to-rgb-rgb-to-hex-using-bash-script/

# redditor zeekar who broke down what those functions did line by line:
# https://reddit.com/r/bash/comments/zqmvz8/rgbhex_converter_syntax_how_does_this_work/

# redditor DyslexicHobo, who suggested ChatGPT, which I used to finalize the
# rgb_to_hex() function. Thank you AI overlords!
# https://openai.com/blog/chatgpt/
