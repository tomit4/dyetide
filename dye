#!/usr/bin/env bash
# set -vx
# set x

printhelp() {
    cat <<EOM
usage: dye [-x|-r] [color_code] "input_color"
options:
 -x [color_code]          hex to [color_code]
 -r [color_code]          rgb to [color_code]
 -h [color_code]          hsl to [color_code]
examples:
 dye -x rgb "#fff"
 dye -x rgb "#ffffff"
 dye -x rgb "#43fF6480"
 dye -r hex "rgb(255, 255, 255)"
 dye -r hsl "rgba(67, 255, 100, 0.8)"
 dye -r hex "rgba(67, 255, 100, 0.5)"
 dye -h hex "hsla(350, 100, 100, 1.0)"
 dye -h rgb "hsl(350, 100, 100)"
EOM
    exit 0
}

error() {
    printf "error: %s\n" "$1" 1>&2
    exit 2
}
rgb_check() {
    if [ "$1" -lt 0 ] || [ "$1" -gt 255 ] || \
        [ "$2" -lt 0 ] || [ "$2" -gt 255 ] || \
        [ "$3" -lt 0 ] || [ "$3" -gt 255 ]; then
        error "invalid rgb values passed."
    fi
}

hex_to_rgb() {
    local a
    # null command ':' removes all leading hashtag characters
    : "${3/\#/}"
    # if hex value is 8 characters
    if ((${#_} == 8)); then
        # convert characters to hex (see credits at bottom)
        ((r = 16#${_:0:2}, g = 16#${_:2:2}, b = 16#${_:4:2}, a = 16#${_:6:2}))
        # simple calc for alpha channel
        a=$(echo "scale=2; $a / 255" | bc -l)
    # else if hex value is 6 characters (no alpha channel)
    elif ((${#_} == 6)); then
        ((r = 16#${_:0:2}, g = 16#${_:2:2}, b = 16#${_:4:2}))
        a=1.0
    # else if hex value is 3 characters (minimal hex value provided)
    elif ((${#_} == 3)); then
        ((r = 16#${_:0:1}${_:0:1}, g = 16#${_:1:1}${_:1:1}, b = 16#${_:2:1}${_:2:1}))
        a=1.0
    else
        error "$3 is not a recognized hex color code."
    fi
    printf "%s\n" "rgba($r, $g, $b, $a)"
}

dec_to_float() {
    echo "scale=2; $1 / 255" | bc -l -l
}

find_min_max() {
   local r=$1
   local g=$2
   local b=$3
   min=$r
   max=$r
   if [[ $(echo "$g > $max" | bc -l) -eq 1 ]]; then
       max=$g
   elif [[ $(echo "$g < $min" | bc -l) -eq 1 ]]; then
       min=$g
   fi
   if [[ $(echo "$b > $max" | bc -l) -eq 1 ]]; then
       max=$b
   elif [[ $(echo "$b < $min" | bc -l) -eq 1 ]]; then
       min=$b
   fi
}

calculate_saturation() {
    local min=$1
    local max=$2
    l=$3
    if [[ $(echo "$max == $min" | bc -l) -eq 1 ]]; then
        printf "%.0f" 0
    else
        if [[ $(echo "$l < 0.5" | bc -l) -eq 1 ]]; then
            printf "%.0f" "$(echo "scale=2; (($max - $min) / ($max + $min) * 100)" | bc -l)"
        else
            printf "%.0f" "$(echo "scale=2; (($max - $min) / (2 - $max - $min) * 100)" | bc -l)"
        fi
    fi
}

calculate_hue() {
    local min=$1
    local max=$2
    if [[ $(echo "$max == $min" | bc -l) -eq 1 ]]; then
        printf "%.0f" 0
    else
        if [[ $(echo "$r == $max" | bc -l) -eq 1 ]]; then
            printf "%.0f" "$(echo "scale=2; 60 * (($g - $b) / ($max - $min))" | bc -l)"
        elif [[ $(echo "$g == $max" | bc -l) -eq 1 ]]; then
            printf "%.0f" "$(echo "scale=2; 60 * (($b - $r) / ($max - $min)) + 120" | bc -l)"
        else
            printf "%.0f" "$(echo "scale=2; 60 * (($r -$g) / ($max - $min)) + 240" | bc -l)"
        fi
    fi
}

hex_to_hsl() {
    local a=1.0
    : "${3/\#/}"
    if ((${#_} == 8)); then
        ((r = 16#${_:0:2}, g = 16#${_:2:2}, b = 16#${_:4:2}, a = 16#${_:6:2}))
        a=$(echo "scale=2; $a / 255" | bc -l)
    elif ((${#_} == 6)); then
        ((r = 16#${_:0:2}, g = 16#${_:2:2}, b = 16#${_:4:2}))
    elif ((${#_} == 3)); then
        ((r = 16#${_:0:1}, g = 16#${_:1:1}, b = 16#${_:2:1}))
        r=$((r * 16 + r))
        g=$((g * 16 + g))
        b=$((b * 16 + b))
    fi
    r=$(dec_to_float "$r")
    g=$(dec_to_float "$g")
    b=$(dec_to_float "$b")
    find_min_max "$r" "$g" "$b"
    l=$(printf "%.0f" "$(echo "scale=2; (($max + $min) / 2 * 100)" | bc -l)")
    s=$(calculate_saturation "$min" "$max" "$l")
    h=$(calculate_hue "$min" "$max")
    if [[ $(echo "$h < 0" | bc -l) -eq 1 ]]; then
        h=$(echo "scale=2; $h + 360" | bc -l)
    fi
    printf "%s\n" "hsla($h, $s, $l, $a)"
}

# parse_rgb() takes rgb string to pass to rgb_to_hex()
parse_rgb_to_hex() {
    local regex='^rgb[a]?[(][0-9]{1,3}, [0-9]{1,3}, [0-9]{1,3}[)]$|^rgb[a]?[(][0-9]{1,3}, [0-9]{1,3}, [0-9]{1,3}, [0-1]?.?[0-9][0-9]?[)]$'
    if [[ $3 =~ $regex ]]; then
        local numbers
        numbers=$(echo "$3" | sed -n 's/.*\(([^()]*)\).*/\1/p' | sed 's/[()]//g' | sed 's/,\s/ /g')
        read -r -a rgb <<< "$numbers"
        rgb_check "${rgb[$"0"]}" "${rgb[$"1"]}" "${rgb[$"2"]}" "${rgb[$"3"]}"
        rgb_to_hex  "${rgb[$"0"]}" "${rgb[$"1"]}" "${rgb[$"2"]}" "${rgb[$"3"]}"
    else
        error "pattern passed is not valid rgba format"
    fi
}

rgb_to_hex() {
    local a
    # if a fourth arg is provided (alpha channel)
    if [[ -n "$4" ]]; then
        # converts alpha channel to hex (see below)
        a=$(printf "%02x\n" "$(echo "scale=0; $4*255" | bc -l)" 2>/dev/null)
        # pads hex value with leading 0s
        printf "#%02x%02x%02x%s\n" "$1" "$2" "$3" "$a"
    else
        # pads hex value with leading 0s
        printf "#%02x%02x%02x\n" "$1" "$2" "$3"
    fi
}

parse_rgb_to_hsl() {
    local regex='^rgb[a]?[(][0-9]{1,3}, [0-9]{1,3}, [0-9]{1,3}[)]$|^rgb[a]?[(][0-9]{1,3}, [0-9]{1,3}, [0-9]{1,3}, [0-1]?.?[0-9][0-9]?[)]$'
    if [[ $3 =~ $regex ]]; then
        local numbers
        numbers=$(echo "$3" | sed -n 's/.*\(([^()]*)\).*/\1/p' | sed 's/[()]//g' | sed 's/,\s/ /g')
        read -r -a rgb <<< "$numbers"
        rgb_check "${rgb[$"0"]}" "${rgb[$"1"]}" "${rgb[$"2"]}" "${rgb[$"3"]}"
        rgb_to_hsl  "${rgb[$"0"]}" "${rgb[$"1"]}" "${rgb[$"2"]}" "${rgb[$"3"]}"
    else
        error "pattern passed is not valid rgba format"
    fi
}

# runtime error here, enter standard 'dye -r hsl "rgb(255, 255, 255)"'
# strange bug, 'dye -r hsl "rgb(255, 255, 254)" works just fine for some reason...'
rgb_to_hsl() {
    r=$(echo "scale=2; $1 / 255" | bc -l)
    g=$(echo "scale=2; $2 / 255" | bc -l)
    b=$(echo "scale=2; $3 / 255" | bc -l)

    local a
    if [[ -n "$4" ]]; then
        a="$4"
    else
        a=1.0
    fi

    find_min_max "$r" "$g" "$b"

    if [[ $(echo "$max == $r" | bc -l) -eq 1 ]]; then
        h=$(echo "(($g - $b) / ($max - $min))" | bc -l)
    elif [[ $(echo "$max == $g" | bc -l) -eq 1 ]]; then
        h=$(echo "(($b - $r) / ($max - $min)) + 2" | bc -l)
    else
        h=$(echo "(($r - $g) / ($max - $min)) + 4" | bc -l)
    fi

    s=$(echo "(($max - $min) / (1 - $min))" | bc -l)
    l=$(echo "(($max + $min) / 2)" | bc -l)

    h=$(printf "%.0f" "$(echo "($h * 60)" | bc -l)")
    if [[ $(echo "$h < 0" | bc -l) -eq 1 ]]; then
        h=$(printf "%.0f" "$(echo "$h +360" | bc -l)")
    fi
    s=$(printf "%.0f" "$(echo "($s * 100)" | bc -l)")
    l=$(printf "%0.f" "$(echo "($l * 100)" | bc -l)")

    printf "%s\n" "hsla($h, $s, $l, $a)"
}

parse_hsl_to_hex() {
    local regex='^hsl[a]?[(][0-9]{1,3}, [0-9]{1,3}, [0-9]{1,3}[)]$|^hsl[a]?[(][0-9]{1,3}, [0-9]{1,3}, [0-9]{1,3}, [0-1]?.?[0-9]?[0-9][)]$'
    if [[ $3 =~ $regex ]]; then
        local numbers
        numbers=$(echo "$3" | sed -n 's/.*\(([^()]*)\).*/\1/p' | sed 's/[()]//g' | sed 's/,\s/ /g')
        read -r -a hsl <<< "$numbers"
        hsl_to_hex  "${hsl[$"0"]}" "${hsl[$"1"]}" "${hsl[$"2"]}" "${hsl[$"3"]}"
    else
        error "pattern passed is not valid hsla format"
    fi
}

# Convert RGB values to HEX
# function rgb_to_hex() {
    # local red=$1
    # local green=$2
    # local blue=$3
    # printf '#%02X%02X%02X' $red $green $blue
# }

# Convert HSL to HEX
# function hsl_to_hex() {
    # local hue=$1
    # local saturation=$2
    # local lightness=$3

    # Convert HSL to RGB
    # local red green blue
    # read red green blue <<< $(hsl_to_rgb $hue $saturation $lightness)

    # Convert RGB to HEX
    # rgb_to_hex $red $green $blue
# }

# hsl_to_hex() {
# }

# obviously you get you need to refactor this later
parse_hsl_to_rgb() {
    local regex='^hsl[a]?[(][0-9]{1,3}, [0-9]{1,3}, [0-9]{1,3}[)]$|^hsl[a]?[(][0-9]{1,3}, [0-9]{1,3}, [0-9]{1,3}, [0-1]?.?[0-9]?[0-9][)]$'
    if [[ $3 =~ $regex ]]; then
        local numbers
        numbers=$(echo "$3" | sed -n 's/.*\(([^()]*)\).*/\1/p' | sed 's/[()]//g' | sed 's/,\s/ /g')
        read -r -a hsl <<< "$numbers"
        hsl_to_rgb  "${hsl[$"0"]}" "${hsl[$"1"]}" "${hsl[$"2"]}" "${hsl[$"3"]}"
    else
        error "pattern passed is not valid hsla format"
    fi
}

hue_to_rgb() {
    # p=mid
    # q=chroma
    # t=hue
    p=$1 q=$2 t=$3

    if [[ $(echo "$t < 0" | bc -l) -eq "1" ]]; then
        t=$(echo "scale=2; $t + 1" | bc -l)
    fi
    if [[ $(echo "$t > 1" | bc -l) -eq "1" ]]; then
        t=$(echo "scale=2; $t - 1" | bc -l)
    fi

    if [[ $(echo "$t <= 1 / 6" | bc -l) -eq "1" ]]; then
        p=$(echo "scale=2; $p + ($q - $p) * 6 * $t" | bc -l)
        echo "$p"
        exit 0
    elif [[ $(echo "$t < 1 / 2" | bc -l) -eq "1" ]]; then
        p=$q
        echo "$p"
        exit 0
    elif [[ $(echo "$t < 2 / 3" | bc -l) -eq "1" ]]; then
        p=$(echo "scale=2; $p + ($q - $p) * (2 / 3 - $t) * 6" | bc -l)
        echo "$p"
        exit 0
    fi
    echo "$p"
}


hsl_to_rgb() {
    local h s l r g b
    h=$(echo "scale=4; $1 / 360" | bc -l)
    s=$(echo "scale=2; $2 / 100" | bc -l)
    l=$(echo "scale=2; $3 / 100" | bc -l)

    # if a fourth arg is provided (alpha channel)
    if [[ -n "$4" ]]; then
        a=$4
    else
        a=1
    fi

    # color is grey and all three rgb values should be equal to the $l
    if [[ $s == 0 ]]; then
        r=$l
        g=$l
        b=$l
    else
        local q p
        if [[ "$l" < .50 ]]; then
            q=$(echo "scale=2; $l * (100 + $s)" | bc -l)
        else
            q=$(echo "scale=2; $l + $s - $l * $s" | bc -l)
        fi
        p=$(echo "scale=2; 2 * $l - $q" | bc -l)
        # values are slightly off here possibly due to bc or awk calculating
        # incorrectly
        # r=$(hue_to_rgb "$p" "$q" "$(echo "scale=1; $h + 1 / 3" | bc -l)")
        r=$(hue_to_rgb "$p" "$q" "$(echo "$h" | awk '{print $1 + (1 / 3)}')")
        g=$(hue_to_rgb "$p" "$q" "$h")
        b=$(hue_to_rgb "$p" "$q" "$(echo "$h" | awk '{print $1 - (1 / 3)}')")
    fi

    r="$(printf "%.0f" "$(echo "scale=4; $r * 255" | bc -l)")"
    g="$(printf "%.0f" "$(echo "scale=4; $g * 255" | bc -l)")"
    b="$(printf "%.0f" "$(echo "scale=4; $b * 255" | bc -l)")"
    echo "$r $g $b $a"

}

main() {
    [[ "$#" -lt 1 ]] && printhelp

    while getopts ":x:r:h:?" arg; do
        case $arg in
            x)
                if [[ "$2" == "rgb" ]]; then
                    local rgbval clipit
                    rgbval=$(hex_to_rgb "$@")
                    printf "%s\n" "$rgbval"
                    read -e -r -p "save code to clipboard?(y/n): " clipit
                    if [[ "$clipit" == "yes" || "$clipit" == "y" ]]; then
                        printf "%s" "$rgbval" | xclip -sel clip
                    fi
                elif [[ "$2" == "hsl" ]]; then
                    local hslval clipit
                    hslval=$(hex_to_hsl "$@")
                    printf "%s\n" "$hslval"
                    read -e -r -p "save code to clipboard?(y/n): " clipit
                    if [[ "$clipit" == "yes" || "$clipit" == "y" ]]; then
                        printf "%s" "$hslval" | xclip -sel clip
                    fi
                fi
                ;;
            r)
                if [[ "$2" == "hex" ]]; then
                    local hexval clipit
                    hexval=$(parse_rgb_to_hex "$@")
                    printf "%s\n" "$hexval"
                    read -e -r -p "save code to clipboard?(y/n): " clipit
                    if [[ "$clipit" == "yes" || "$clipit" == "y" ]]; then
                        printf "%s" "$hexval" | xclip -sel clip
                    fi
                elif [[ "$2" == "hsl" ]]; then
                    local hslval clipit
                    hslval=$(parse_rgb_to_hsl "$@")
                    printf "%s\n" "$hslval"
                    read -e -r -p "save code to clipboard?(y/n): " clipit
                    if [[ "$clipit" == "yes" || "$clipit" == "y" ]]; then
                        printf "%s" "$hslval" | xclip -sel clip
                    fi
                fi
                ;;
            h)
                if [[ "$2" == "hex" ]]; then
                    local hexval
                    hexval=$(parse_hsl_to_hex "$@")
                    printf "%s\n" "$hexval"

                elif [[ "$2" == "rgb" ]]; then
                    local hslval
                    hslval=$(parse_hsl_to_rgb "$@")
                    printf "%s\n" "$hslval"
                fi
                # if [[ "$2" == "rgb" ]]; then
                    # hsl_to_rgb "$@"
                # elif [[ "$2" == "hex" ]]; then
                    # hsl_to_hex "$@"
                # fi
                ;;
            ?)
                printhelp
                ;;
        esac
    done
}

main "$@"

# Credits:
# Thanks go out to those who helped:

# Akash Mittal, whose article provided the original versions of hex_to_rgb() and rgb_to_hex() taken from
# https://akashmittal.com/code-example-convert-hex-color-to-rgb-rgb-to-hex-using-bash-script/

# redditor zeekar who broke down what those functions did line by line:
# https://reddit.com/r/bash/comments/zqmvz8/rgbhex_converter_syntax_how_does_this_work/

# redditor DyslexicHobo, who suggested ChatGPT, which I used to finalize the
# rgb_to_hex() function. Thank you AI overlords!
# https://openai.com/blog/chatgpt/
